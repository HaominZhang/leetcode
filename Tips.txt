Reverse Integer
res = res * 10 + num%10可以reverse integer,但要首先判断res是否大于(Interger.MAX_VALUE-num%10)/10，如果大于overflow.
Unique Binary Search
考虑每个数字作为根节点，左子树是它之前的数字，右子树是它之后的数字。数目则是两棵子树数目的乘积
LinkedListCycle
slower,faster双指针，faster移动2倍于slower指针，如果在走到链表尾端之前可以遇到，则说明链表存在环。
Populating Next Right Pointer in Each Node
如果左子节点不为空，左子结点的next为右子节点，如果右子节点不为空，那么右子节点的next等于当前节点的next的左子节点。
Search insert position
二分搜索，等于目标返回，不等于切一半。当循环结束时，如果没有找到目标元素，那么l一定停在恰好比目标大的index上，r一定停在恰好比目标小的index上
RemoveDuplicatesFromSortedList
维护两个指针，一个指向当前不重复的最后一个元素，一个进行依次扫描，遇到不重复的则更新第一个指针，继续扫描，否则就把前面指针指向当前元素的下一个（即把当前元素从链表中删除）
RomanToInteger
分类讨论，5，50，500的时候要注意是在当前结果上加还是减。
Single Number II
由于部分字符出现了三次，因此按位累加的时候，对3取余，所有被累加3次的位都应当能被整除，唯一一个出现一次的位就属于single number.
Climbing stairs
简单的动态规划，每一步都可以走1步或者2步，因此递推式为way[i] = way[i-1]+way[i-2]。
Maximum Subarray
DP:局部最优和全局最优。
假设我们已知第i步的global[i]（全局最优）和local[i]（局部最优），那么第i+1步的表达式是：
local[i+1]=Math.max(A[i], local[i]+A[i])，就是局部最优是一定要包含当前元素，所以不然就是上一步的局部最优local[i]+当前元素A[i]（因为local[i]一定包含第i个元素，所以不违反条件），但是如果local[i]是负的，那么加上他就不如不需要的，所以不然就是直接用A[i]；
global[i+1]=Math(local[i+1],global[i])，有了当前一步的局部最优，那么全局最优就是当前的局部最优或者还是原来的全局最优（所有情况都会被涵盖进来，因为最优的解如果不包含当前元素，那么前面会被维护在全局最优里面，如果包含当前元素，那么就是这个局部最优）。
Integer to Roman
贪心算法，把特殊的进位数字，900（CM），400（CD), 90(XC)， 40（XL), 4 (IX)列举出来，然后使用贪心算法，只需要在字符串后进行append。
Remove Element
从队尾将非element元素换到队头element的元素处
N-Queens II
由于只需要返回solution的数量，因此只需要按顺序尝试放置Queen然后检查是否同列或者在对角线上。按照行、列的顺序进行检查，行使用递归，列使用循环。
Converte Sorted Array to Binary Search Tree
使用二分查找，mid元素作为根节点，low到mid作为左子树，mid到high作为右子树
Balanced Binary Search Tree
递归检查BST的左子树深度和右子树深度，两棵子树的深度差如果小于1，那么到目前为止左右子树都balance,因此要返回当前子树的深度，也就是max(left,right)+1。否则返回-1；如果接收到子节点的返回值是-1，就不用继续检查直接return。否则需要继续递归检查。
Swap Node in Pairs
建立一个伪头结点，便于操作头结点，然后按顺序两两交换node，1节点的next等于2节点的next，2节点的next等于2节点的next的next，1节点的next的next等于2节点。然后两个往后顺移。
ListNode pre = fake;  
        ListNode cur = head;  
          
        while(cur != null && cur.next != null){  
            pre.next = cur.next;  
            cur.next = cur.next.next;  
            pre.next.next = cur;  
  
            pre = cur;  
            cur = pre.next;  
        }  

Remove Duplicates from Sorted Array
使用两个指针，一个指针跟随循环不断向后移动，另外一个只有在遇到非相同元素的时候才移动，如果是第一个元素直接向后移动。否则不动等待自动移动的指针找到一个与当前位置不同的值然后进行copy.

Is symmetric tree
使用same tree函数作为helper，只不过在传值的时候要传对应的node，传一棵树的左子树的时候，另外一个参数是另一个树的右子树

Merge Sorted Array
由于数组A尾部存在足够大的空间，因此赋值要从A的尾部开始进行，利用A,B的长度m,n作为指针，一个index作为插入的位置指针，如果数组A的数字已经全部插入完，则数组的剩余空间由B填满，否则插入完成。当A,B都有数字时，比较大小。先移动后插入。

Gray Code
格雷码的规律是，n-1位格雷码下面接倒序排列的n-1位格雷码，然后对前半部分的n-1位格雷码前面填0，后半部分剩余的格雷码前面填1. Base case 是0和1的格雷码，然后从数组尾部开始倒序检查，用位移操作将1左移n-1位。

Pascal Triangle
每一行都要使用上一行的信息。首先要在每行的开头和结尾都添加1，然后对上一行的每两个元素求和加入到当前行中。中间循环重复的次数取决于triangle的行数。

Sort Color
知道要排序的元素的范围可以使用计数排序，比如此题中知道颜色为0，1，2，可以利用计数原理按顺序为0，1，2留出足够的位置，相当于O(n)的排序。

Plus One
由于只是+1，一旦有一位没有进位，那么计算就结束了，因此只要carry==0，直接return。当进行到最高位时，如果还有carry，要new一个长度+1的数组，并且最高位设为1，其余位一定为0.因为是+1的计算，所以不用一个一个赋值为0.

Generate Parentheses
递归求解，需要注意的几点，1：右括号的剩余数量不能比左括号少。2：如果左右括号都用完了，加到list里。

Best Time to Buy and Sell Stock
思路同maximum subarray,维护一个Local和一个global。local每次要比较之前的总价和前一天买入当天的卖出价差与之前的利润和，如果大于0则说明操作有利可以更新local。global则是比较交易中的最大利润。

Unique Path
二维DP.首先要将第一行和第一列都设为1，然后可以求出递推式path[i][j] = path[i-1][j] + path[i][j-1]; 最后只需要返回path[m-1][n-1]即可。

Rotate Image
如果可以使用额外空间，就找出旋转方向然后循环拷贝。没有额外空间，利用规律
	for (int i = 0; i < n / 2; i++) {
    		for (int j = 0; j < Math.ceil(((double) n) / 2.); j++) {
    			int temp = matrix[i][j];
    			matrix[i][j] = matrix[n-1-j][i];
    			matrix[n-1-j][i] = matrix[n-1-i][n-1-j];
    			matrix[n-1-i][n-1-j] = matrix[j][n-1-i];
    			matrix[j][n-1-i] = temp;
    		}
    	}

Minimum Path Sum
二维DP.思路和Unique Path是一样的，维护一个二维数组记录权值，每个位置需要保存的是上方或者左侧更小的一个位置加上该格子自身的权值。

Permutations
NP问题。要用递归对每一种可能性进行检查。因为数字出现的顺序会改变，并且不能出现重复的数字，因此在每一层递归循环检查的时候，还要使用一个used数组来保证数字不会被重复使用。

Search a 2D Matrix
使用两次二分查找。

Binary Tree Level Order Traversal
BFS.每一层都用一个arraylist保存当前节点信息。进入下一层的时候，用一个Parent arraylist保存上一层的信息，然后每一层声明一个新的arraylist进行替换。

Container with Most Water
两个指针一头一尾向中间移动，保存一个最大体积，每次移动瓶颈指针，直到指针交错。类似于2SUM

Set Matrix Zeroes
使用两个boolean数组来保存信息空间是O(m+n).为了达到O(1)可以使用每一行或者每一列的第一个元素保存信息。首先要特殊判断第一行和第一列是否需要set 0。用两个boolean flag来标记。然后按顺序遍历，如果发现0，就把那所在行和列的第一个元素置0.再次遍历时检查行和列的第一个元素，如果是0就把那个位置set 0.

Search in Rotated Sorted Array II
先用二分，然后确定左边是不是有序的，也就是A[mid]和A[low]的关系，如果A[low]>A[mid]，再去右边继续二分。如果不是，在左边二分。如果相等，那low++跳过这次判断。

Remove Duplicates from Sorted Array II
与I类似，都是遇到不相同的元素再移动位置指针，区别是最多允许2次重复，因此要用一个counter计数，一旦超出计数就跳过当前元素。

Pascal Triangle II
可以使用一行数据来保存历史信息，下一行的r[i] = r[i]+r[i+1]。但是如果只用r来保存的话，保存新信息的时候原数据会被替换掉，因此要从尾部开始向前遍历。即r[i] = r[i] +r[i-1];

Populating Next Right Pointer in Each Node II
在每一层都维护一个pre指针，和一个下一层的head指针，然后每一层都从head指针出发，如果是子树是空就把pre = pre.next，否则就与子树相连。

Palindrome Number
获取x的位数，然后按位把x颠倒，看新得到的数字是否和原数字相等。

Length of Last Word
从字符串最后一个字符开始判断，如果不是空格count++，如果是空格且count!=0就说明word已经被记录过了，否则会继续记录。

Trapping Rain Water
基本思路就是维护一个长度为n的数组，进行两次扫描，一次从左往右，一次从右往左。第一次扫描的时候维护对于每一个bar左边最大的高度是多少，存入数组对应元素中，第二次扫描的时候维护右边最大的高度，并且比较将左边和右边小的最大高度（我们成为瓶颈）存入数组对应元素中。这样两遍扫描之后就可以得到每一个bar能承受的最大水量，从而累加得出结果。这个方法只需要两次扫描，所以时间复杂度是O(2*n)=O(n)。空间上需要一个长度为n的数组，复杂度是O(n)。

Longest Consecutive Sequence
实际上是BFS，将所有的数字用hashset保存，然后查看对于当前检查数字的下一个是否在列表里，如果在就继续找下去，直到不存在。然后再检查当前数字的前一个是否在，在的话继续向前找。找的过程中要把visited的节点从set中删去。当前字符检查完之后，保存到目前为止最长的字符串长度。

Unique Path II
可以用unique path I中的方法，但是要特殊考虑第一行和第一列，如果遇到是1的话，设置为特殊值，最后累加的时候就可以不考虑了。
更好的是使用一维DP。如果是block，r[j] = 0；否则r[j]+=r[j-1]；按顺序查看位置即可。

Valid Sudoku
brute force。唯一的trick是在按方格检查的时候可以使用如下坐标表示
for(int block=0;block<9;block++)  
    {  
        boolean[] map = new boolean[9];  
        for(int i=block/3*3;i<block/3*3+3;i++)  
        {  
            for(int j=block%3*3;j<block%3*3+3;j++)  
            {  
                if(board[i][j] != '.')  
                {  
                   if(map[(int)(board[i][j]-'1')])  
                   {  
                      return false;  
                   }  
                   map[(int)(board[i][j]-'1')] = true;      
                }  
            }  
        }  
    }  

Flatten Binary Tree
用arraylist保存当前检查的节点的前一个节点，然后递归把左子树接到Pre后面，然后pre更新。要注意的是，在移动子树前要保存右子树的信息，否则重新连接后右子树会丢失。

Subsets.
NP问题。与其他问题有所不同的是，使用递归的话要从最底层开始向arraylist中添加元素，然后再向上弹栈的过程中，不断向arraylist中已经存在的子集中添加元素。

Search in a Range
这道题并不要求我们找到准确的位置，而是要求我们找到一个范围。不过思想还是使用二分查找。如果最终找不到准确的值，那么最后low>high但是我们还是没有找到target，那么就返回[-1,-1]。如果找到，那么我们还要继续确定范围。继续二分查找，先找左边界，再找右边界。

Path Sum II
与Path Sum一样要用递归的方式一层一层向下递减元素和，不同的是将每一层的节点存入arraylist里，如果有子节点就要继续递归。当递归返回时，要把最新加入的节点删掉以便其他子树继续使用。

Jump Game
DP.局部最优和全局最优问题。局部最优是当前index+A[index]，全局最优是local和历史记录的比较，如果全局最优的结果超过了数组的长度-1，那么就是true.

Longest Common Prefix
brute force，一个一个的比较字符串的前缀。需要注意的是如果字符串为空的话，可以直接返回空串。

Convert Sorted List to Binary Search Tree.
如果是array，我们可以直接操作index，但是list没办法，只能通过中序遍历。思想跟array类似，low和high来作为终止条件。首先遍历左子树把左子树都遍历完之后，设置根节点，然后根节点更新为链表的下一个元素，继续进行右子树的遍历。

Count and Say
计数并打印。原理是逐一对list的每个数字进行计数，遇到一个不相同的数字就把之前记录的count和number都append进list中。跳出循环时要记得将最后一次计算的结果页加入到结果列表中。

3Sum Closeset
思路跟3Sum是一样的，用类似于二分查找的方法从两头往中间夹，需要注意的是全局的min要保存的值是targer和sum的差，而最终的返回值则是sum。所以分开保存会更加清晰一点，不容易混乱。

Unique Binary Search Tree II
有了Unique Binary Search Tree的经验我们知道，应该循环将每个数字都当做当前的根节点，然后之前的数字当做左子树，之后的数字当做右子树。递归调用分别得到左子树和右子树之后，应该将它们两两组合起来才能产生全部的BST.

Triangle
一维DP。从三角形的最底层往上走，因为只能走相邻节点，因此上一行sum[i]等于下一层sum[i]，sum[i+1]中更小的一个加上自己本身的值。直到走到三角形顶端返回sum[0]即可。

Subsets II
与Subsets类似，只不过数组里出现了重复的字符，因此需要在内层循环时跳过重复的元素，外层循环依次查看元素的时候并不需要跳过。while(i < num.length-1 && num[i] == num[i+1]) i++;  
要加在当前内层循环完成查找之后

Partition List
用两个链表一个存小的数，一个存大的数，然后两个链表Merge

Combination Sum
一开始sum为0，逐步往下递归之后，传给下一层的值是当前位置的val加上之前的sum，但是由于同一个数字可以重复使用，但是不能回头使用更小的数字，因此每次传给下一层的循环起始位置是和上一层相同的。因为数字可以重复使用，所以当遇到相同数字时可以直接跳过。

Construct Binary Tree From Preorder and Inorder
按照先序遍历排列的节点，是按照根节点--左子树根节点--右子树根节点的顺序排列的。因此每次递归调用建立树时，可以通过查看每一层先序遍历的结点获得当前的根节点。然后在中序遍历中找到此节点，那么前半部分就是左子树的节点，后半部分就是右子树的节点。然后按照左子树、右子树的顺序，将它们对应的先序遍历和中序遍历的节点递归传递下去。
Constructe Binary Tree from Inorder and Postorder同理，只不过要从postorder的尾部开始向前找，前半部分是右子树的节点，后半部分是左子树的节点。

pow(x,n)
如果一个一个乘的话O(n)会超时，所以要考虑更加优化的情况。可以使用递归也可以使用循环，思路是设置一个初始值val = 1，当n为偶数的时候，x = x*x，否则是x = x*val，最后返回val。n每次都要变成一半。

Letter Combinations of a phone number
与combination很类似，首先要确定每个数字对应的字符串都是什么，因此可以用状态机或者hashmap来建立对应关系。然后就是递归调用，按顺序检查每个数字，然后按数字递归调用。如果用数组来做，数字字符串的长度就是每个List里面，单个string的长度，在使用时可以提前声明。如果用arraylist就不用那么麻烦了。

Reverse Linked List II
先循环走到要reverse的节点的前一个位置上，然后一个接一个reverse就好了。需要设置一个伪头结点来处理头结点的交换。

Palindrome Partitioning
结构上和NP问题是一样的，需要注意的细节是如何传递index。
	for(int i=start+1;i<=s.length();i++){
	        	String substr = s.substring(start,i);
	           StringBuffer str = new StringBuffer(substr);
	      
	           if(substr.equals(str.reverse().toString())){
	               plist.add(substr);
	               partitionHelper(s,i,returnlist,plist);
	               plist.remove(plist.size()-1);
	         }
	}
这里的start,substring的参数，以及递归给下一层的start参数非常tricky。可以选择用stringbuffer得reverse方法来检查是否是回文，也可以提前写好函数将所有的回文串都保存起来。

Add Binary
由于是二进制字符串的加法，所以不能先转换成整数再加和，会导致溢出。因此首先要对齐两个字符串，短的字符串前面补0.然后求和+carry。此处的精髓在于求carry和digit.对sum/2可以得到carry,对sum取2的余数可以得到digit.如果使用字符串来表示结果，digit是sum%2+digit。如果只是用Integer就不用加digit。

N-Queens
NP问题，按顺序在从第一列开始放，检查是否与之前情况冲突，不冲突然后递归进入下一行.

Validate Binary Search Tree
首先需要检查左根节点的值要小于右根节点的值，还需要注意左子树要保存一个min,右子树要保存一个max，使得左节点始终可以小于当前根节点，但是大于最小值，右节点始终大于当前根节点，但是小于最大值。

Next Permutation
规律是，从数组最后一个位置开始找，找到第一个非递增数字，记录位置p。如果整个数组从后往前都是递增的，那么需要整个翻转数组。否则从记录到的位置往后找，找到下一个位置的数字比num[p]要小的位置q，交换num[p]和num[q]。然后再把p之后的数字倒序。
比如排列是(2,3,6,5,4,1)，求下一个排列的基本步骤是这样：
1) 先从后往前找到第一个不是依次增长的数，记录下位置p。比如例子中的3，对应的位置是1;
2) 接下来分两种情况：
    (1) 如果上面的数字都是依次增长的，那么说明这是最后一个排列，下一个就是第一个，其实把所有数字反转过来即可(比如(6,5,4,3,2,1)下一个是(1,2,3,4,5,6));
    (2) 否则，如果p存在，从p开始往后找，找到下一个数就比p对应的数小的数字，然后两个调换位置，比如例子中的4。调换位置后得到(2,4,6,5,3,1)。最后把p之后的所有数字倒序，比如例子中得到(2,4,1,3,5,6), 这个即是要求的下一个排列。

Edit Distance
我们维护的变量res[i][j]表示的是word1的前i个字符和word2的前j个字符编辑的最少操作数是多少。假设我们拥有res[i][j]前的所有历史信息，看看如何在常量时间内得到当前的res[i][j]，我们讨论两种情况：
1）如果word1[i-1]=word2[j-1]，也就是当前两个字符相同，也就是不需要编辑，那么很容易得到res[i][j]=res[i-1][j-1]，因为新加入的字符不用编辑；
2）如果word1[i-1]!=word2[j-1]，那么我们就考虑三种操作，如果是插入word1，那么res[i][j]=res[i-1][j]+1，也就是取word1前i-1个字符和word2前j个字符的最好结果，然后添加一个插入操作；如果是插入word2，那么res[i][j]=res[i][j-1]+1，道理同上面一种操作；如果是替换操作，那么类似于上面第一种情况，但是要加一个替换操作（因为word1[i-1]和word2[j-1]不相等），所以递推式是res[i][j]=res[i-1][j-1]+1。上面列举的情况包含了所有可能性，有朋友可能会说为什么没有删除操作，其实这里添加一个插入操作永远能得到与一个删除操作相同的效果，所以删除不会使最少操作数变得更好，因此如果我们是正向考虑，则不需要删除操作。取上面几种情况最小的操作数，即为第二种情况的结果，即res[i][j] = min(res[i-1][j], res[i][j-1], res[i-1][j-1])+1。

Insertion Sort List
需要声明一个伪链表头作为排序过后的链表头。从原链表头开始扫描，遇到非顺序的值就接到伪链表头后面，然后对于新链表，每次插入完成后指针都回到伪链表头，如果插入位置不合适则指向新链表的指针向后移。

Reverse Nodes in k-Groups
建立伪链表头，然后用Pre指针表示翻转过后的链表头，循环k次走到要最后一个要反转的位置上进行翻转。然后更新pre等位置。

Gas Station
记录两个信息，当前油量剩余总和，和全局油量剩余总和。当前剩余油量总和一旦小于0就清空并且记录此时index，全局油量剩余总和始终累加。最后判断全局油量剩余和是否大于0，大于0说明存在一个位置返回index+1，否则不存在。

Remove duplicates from Sorted list II
把前驱指针指向上一个不重复的元素中，如果找到不重复元素，则把前驱指针知道该元素，否则删除此元素。


Permutations II
对于重复的元素循环时跳过递归函数的调用，只对第一个未被使用的进行递归，我们那么这一次结果会出现在第一个的递归函数结果中，而后面重复的会被略过。如果第一个重复元素前面的元素还没在当前结果中，那么我们不需要进行递归。

Distinct Subsequences
假设我们现在拥有之前的历史信息，我们怎么在常量操作时间内得到res[i][j]。假设S的第i个字符和T的第j个字符不相同，那么就意味着res[i][j]的值跟res[i-1][j]是一样的，前面该是多少还是多少，而第i个字符的加入也不会多出来任何可行结果。如果S的第i个字符和T的第j个字符相同，那么所有res[i-1][j-1]中满足的结果都会成为新的满足的序列，当然res[i-1][j]的也仍是可行结果，所以res[i][j]=[i-1][j-1]+res[i-1][j]。所以综合上面两种情况，递推式应该是res[i][j]=(S[i]==T[j]?res[i-1][j-1]:0)+res[i][j]。
实现的时候可以从T字符串的尾部开始匹配，可以少匹配一个。

Jump Game II
只是原来的全局最优现在要分成step步最优和step-1步最优（假设当前步数是step）。当走到超过step-1步最远的位置时，说明step-1不能到达当前一步，我们就可以更新步数，将step+1

Combination Sum II
与I相同，只是不能使用重复数字了。因此在递归传值的时候要传递的Index要+1.

ZigZag conversion
数学题不说了。

Recover Binary Search Tree
使用中序遍历，用LastElement记录上一次最后访问的节点，那么lastELement中保留的节点顺序应该是先左后中后右，那么一旦当前所在节点的值小于上一次visited的节点了，就说明这个节点是错误的。先给Node1赋值,node1不空再给node2赋值，然后交换两个Node的值就可以了。

Anagrams
将每个字符串sort，然后存进hashmap里，如果是变形词，排序后的结果应当是一样的。那么就把这个词对应的arraylist里面加上。否则作为新结点put进map里。然后用itertator遍历map的value，如果arraylist的size>1，就说明有词是变形词，那么就加到结果中。

copy list with random pointer
先按顺序copy链表，不用管randompointer,将新生成的节点连接在原节点后面。等链表都copy完了，重新返回头结点，node.next.random = node.random.next，然后每次移动两步。然后新生命一个头结点，把所有复制出来的节点连接上。
或者使用hashmap，将新老节点对应上，然后通过老节点找到老random节点，然后通过map将老random节点对应的新random节点连上。

Add Two Numbers
新建伪链表头，然后list1和list2对应位置相加，保存的值是sum%10，而进位则直接可以通过sum/10计算，跳出循环后要判断是否还有进位，如果有进位新建一个node(1)接在链表尾部。

Valid Palindrome
双指针，一头一尾，遇空格跳过。判断非空格字符是不是相同。

Scramble String
这其实是一道三维动态规划的题目，我们提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。
有了维护量我们接下来看看递推式，也就是怎么根据历史信息来得到res[i][j][len]。判断这个是不是满足，其实我们首先是把当前s1[i...i+len-1]字符串劈一刀分成两部分，然后分两种情况：第一种是左边和s2[j...j+len-1]左边部分是不是scramble，以及右边和s2[j...j+len-1]右边部分是不是scramble；第二种情况是左边和s2[j...j+len-1]右边部分是不是scramble，以及右边和s2[j...j+len-1]左边部分是不是scramble。如果以上两种情况有一种成立，说明s1[i...i+len-1]和s2[j...j+len-1]是scramble的。而对于判断这些左右部分是不是scramble我们是有历史信息的，因为长度小于n的所有情况我们都在前面求解过了（也就是长度是最外层循环）。
上面说的是劈一刀的情况，对于s1[i...i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。
总结起来递推式是res[i][j][len] = || (res[i][j][k]&&res[i+k][j+k][len-k] || res[i][j+len-k][k]&&res[i+k][j][len-k]) 对于所有1<=k<len，也就是对于所有len-1种劈法的结果求或运算。因为信息都是计算过的，对于每种劈法只需要常量操作即可完成，因此求解递推式是需要O(len)（因为len-1种劈法）。

Clone Graph
BFS，用hashmap当做visited，注意访问节点后把新节点加入queue，并且加入到当前访问节点的neighbor中。

First Missing Positive
跟Counting sort一样，利用数组的index来作为数字本身的索引，把正数按照递增顺序依次放到数组中。即让A[0]=1, A[1]=2, A[2]=3, ... , 这样一来，最后如果哪个数组元素违反了A[i]=i+1即说明i+1就是我们要求的第一个缺失的正数。对于那些不在范围内的数字，我们可以直接跳过，比如说负数，0，或者超过数组长度的正数，这些都不会是我们的答案。实现中还需要注意一个细节，就是如果当前的数字所对应的下标已经是对应数字了，那么我们也需要跳过，因为那个位置的数字已经满足要求了，否则会出现一直来回交换的死循环。

Best Time to Buy and Sell Stock III
因为规定了只能两次交易因此可以使用类似二分查找的方法，将两次交易看成左右两个部分，profit就是两部分和的最大值。因此从左扫描一遍找最小的买入价，从右扫描一遍找最大的卖出价，然后对应相加和maxprofit比较即可。

sqrt(x)
二分查找，在0和当前数字中间取mid，然后看mid*mid和X的大小，然后砍掉一半继续计算。
注意最后一次跳出循环后还要再计算一次mid才是最终结果。

Merge K sorted List
利用mergesort，将任务划分成子任务，分到不能再分，然后两两开始merge。

Longest Substring Without Reapting Character
按字符检查，用extra space保存用过的字符，如果遇到用过的字符就比较一下maxlength，然后检查下一个字符。

Rotate List
首先找到链表尾，然后和头连起来形成一个环，然后得到k的值int k = len - n%len;
然后循环K次找到对应的节点，将该节点的next链接断开指向NULL即可。

Permutation sequence
这道题目算法上没有什么特别的，更像是一道找规律的数学题目。我们知道，n个数的permutation总共有n阶乘个，基于这个性质我们可以得到某一位对应的数字是哪一个。思路是这样的，比如当前长度是n，我们知道每个相同的起始元素对应(n-1)!个permutation，也就是(n-1)!个permutation后会换一个起始元素。因此，只要当前的k进行(n-1)!取余，得到的数字就是当前剩余数组的index，如此就可以得到对应的元素。如此递推直到数组中没有元素结束。

假设我们把矩阵沿着某一行切下来，然后把切的行作为底面，将自底面往上的矩阵看成一个直方图（histogram）。直方图的中每个项的高度就是从底面行开始往上1的数量。根据Largest Rectangle in Histogram我们就可以求出当前行作为矩阵下边缘的一个最大矩阵。接下来如果对每一行都做一次Largest Rectangle in Histogram，从其中选出最大的矩阵，那么它就是整个矩阵中面积最大的子矩阵。
算法的基本思路已经出来了，剩下的就是一些节省时间空间的问题了。
我们如何计算某一行为底面时直方图的高度呢？ 如果重新计算，那么每次需要的计算数量就是当前行数乘以列数。然而在这里我们会发现一些动态规划的踪迹，如果我们知道上一行直方图的高度，我们只需要看新加进来的行（底面）上对应的列元素是不是0，如果是，则高度是0，否则则是上一行直方图的高度加1。利用历史信息，我们就可以在线行时间内完成对高度的更新。我们知道，Largest Rectangle in Histogram的算法复杂度是O(n)。所以完成对一行为底边的矩阵求解复杂度是O(n+n)=O(n)。接下来对每一行都做一次，那么算法总时间复杂度是O(m*n)。

Implement strStr()
brute force.注意字符的边界，不要越界，剩下的就是一个字符一个字符对应查找就好了。

Largest Rectangle in Histogram
思路跟Longest Valid Parentheses比较类似，我们要维护一个栈，这个栈从低向上的高度是依次递增的，如果遇到当前bar高度比栈顶元素低，那么就出栈直到满足条件，过程中检测前面满足条件的矩阵。关键问题就在于在出栈时如何确定当前出栈元素的所对应的高度的最大范围是多少。答案跟Longest Valid Parentheses中括号的范围相似，就是如果栈已经为空，说明到目前为止所有元素（当前下标元素除外）都比出栈元素高度要大（否则栈中肯定还有元素），所以矩阵面积就是高度乘以当前下标i。如果栈不为空，那么就是从当前栈顶元素的下一个到当前下标的元素之前都比出栈元素高度大（因为栈顶元素第一个比当前出栈元素小的）

Sudoku Solver
原理上跟N-Queens是一样的，实际操作上在进入下一个格子的时候不像N-Queens用循环进入下一行，而是用递归进入下一个格子。在每个格子上都用1-9尝试一次，用valid sudoku做辅助函数检测是否满足条件，满足再进入下一个格子。	不满足要记得将格子重置回"."

Word Break
思想是DP。对于每一个字符，都检测它之前的字符串是否在字典中，检查的时候先用substring取到当前字符串为止，然后再从头一个字母一个字母的删除，如果是就把对应位置flag置true。

Merge Intervals
这道题由于给定的collection并不一定是排好序的，因此我们首先要做一个排序，先按照start排序，start相同再按照end排序。需要override compare函数。排好序之后就要比较前一个的end是否大于后一个start，如果大于说明需要合并，因此要再比较两个end，选择大的一个作为最终的end。如果end小于下一个的start,可以直接把下一个加入到result中。

Spiral Matrix
找规律移动就好了，注意row==1和col==1的特殊情况。

Multiply Strings
    直接乘会溢出，所以每次都要两个single digit相乘，最大81，不会溢出。
    比如385 * 97, 就是个位=5 * 7，十位=8 * 7 + 5 * 9 ，百位=3 * 7 + 8 * 9 …
    可以每一位用一个Int表示，存在一个int[]里面。
    这个数组最大长度是num1.len + num2.len，比如99 * 99，最大不会超过10000，所以4位就够了。
    这种个位在后面的，不好做（10的0次方，可惜对应位的数组index不是0而是n-1），
    所以干脆先把string reverse了代码就清晰好多。
    最后结果前面的0要清掉。

Longest Palindrome Substring
回文字符的很重要一个特点是，可以以一个字符为对称轴或者以两个字符的中心为对称轴。所以我们需要分别检查两种不停的情况。每个字符都要遍历一次，以当前字符为中心，或者以当前字符与下一个字符为中心，向两边扩展检查。然后取最大的长度即可。

Restore IP Address
IP由4段组成，每段的范围都是0-255，因此首先要确定当前段的最大长度和最小长度。然后通过递归尝试不同的长度，然后判断该段字符串所代表的数字是不是大于0小于255，是的话可以继续递归，否则尝试新的长度。一开始是空字符串，所以要直接添加数组，否则需要先添加"."。

Sort List
时间要求是O(nlogn)，那就是mergesort了，每次都用faster和slower找到中间位置，然后断开原来的链表，最后Merge two sorted list就好了。

Insert Interval
首先通过insert的start和原有的end做比较找到应当插入的位置，然后再比较insert的start和插入的start看是否需要覆盖，暂时不需要处理insert的end.当处理好start后将insert插入，然后向后扫描end应该到哪里结束，搜索直到insert的end小于原表中end时结束，进行覆盖。然后将原表中剩余的元素都插入新表结束。

Reorder List
用slower faster找到链表的中点，然后将链表分割成两个子链表。前半部分不动，后半部分reverse变成原来链表的尾作为新链表的头。然后两个Merge

Regular Expression Matching
思路就是先看字符串s和p的从i和j开始的子串是否匹配，用递归的方法直到串的最后，最后回溯回来得到结果。假设现在走到s的i位置，p的j位置，情况分为下列两种： 
(1)p[j+1]不是'*'。情况比较简单，只要判断当前s的i和p的j上的字符是否一样（如果有p在j上的字符是'.',也是相同），如果不同，返回false，否则，递归下一层i+1，j+1; 
(2)p[j+1]是'*'。那么此时看从s[i]开始的子串，假设s[i],s[i+1],...s[i+k]都等于p[j]那么意味着这些都有可能是合适的匹配，那么递归对于剩下的(i,j+2),(i+1,j+2),...,(i+k,j+2)都要尝试（j+2是因为跳过当前和下一个'*'字符）。 
接下来我们考虑如何优化brute force算法，熟悉动态规划的朋友可能发现了，其实这个思路已经很接近动态规划了。动态规划基本思想就是把我们计算过的历史信息记录下来，等到要用到的时候就直接使用，不用重新计算。在这个题里面，假设我们维护一个布尔数组res[i][j],代表s的前i个字符和p的前j个字符是否匹配(注意这里res的维度是s.length()+1,p.length()+1)。递推公式跟上面类似，分三种种情况： 
(1)p[j+1]不是'*'。情况比较简单，只要判断如果当前s的i和p的j上的字符一样（如果有p在j上的字符是'.',也是相同），并且res[i][j]==true，则res[i+1][j+1]也为true，res[i+1][j+1]=false; 
(2)p[j+1]是'*'，但是p[j]!='.'。那么只要以下条件有一个满足即可对res[i+1][j+1]赋值为true： 
    1)res[i+1][j]为真（'*'只取前面字符一次）; 
    2)res[i+1][j-1]为真（'*'前面字符一次都不取，也就是忽略这两个字符）; 
    3)res[i][j+1] && s[i]==s[i-1] && s[i-1]==p[j-1](这种情况是相当于i从0到s.length()扫过来，如果p[j+1]对应的字符是‘*’那就意味着接下来的串就可以依次匹配下来，如果下面的字符一直重复，并且就是‘*’前面的那个字符）。 
(3)p[j+1]是'*'，并且p[j]=='.'。因为".*"可以匹配任意字符串，所以在前面的res[i+1][j-1]或者res[i+1][j]中只要有i+1是true，那么剩下的res[i+1][j+1],res[i+2][j+1],...,res[s.length()][j+1]就都是true了。 

Binary Tree Maximum Sum
这道题是求树的路径和的题目，不过和平常不同的是这里的路径不仅可以从根到某一个结点，而且路径可以从左子树某一个结点，然后到达右子树的结点，就像题目中所说的可以起始和终结于任何结点。在这里树没有被看成有向图，而是被当成无向图来寻找路径。因为这个路径的灵活性，我们需要对递归返回值进行一些调整，而不是通常的返回要求的结果。在这里，函数的返回值定义为以自己为根的一条从根到子结点的最长路径（这里路径就不是当成无向图了，必须往单方向走）。这个返回值是为了提供给它的父结点计算自身的最长路径用，而结点自身的最长路径（也就是可以从左到右那种）则只需计算然后更新即可。这样一来，一个结点自身的最长路径就是它的左子树返回值（如果大于0的话），加上右子树的返回值（如果大于0的话），再加上自己的值。而返回值则是自己的值加上左子树返回值，右子树返回值或者0（注意这里是“或者”，而不是“加上”，因为返回值只取一支的路径和）。在过程中求得当前最长路径时比较一下是不是目前最长的，如果是则更新。

Word Search
在二维矩阵中查找某个字符串的存在，实际上是图的DFS。对于每一个(i,j)的上下左右四个方向都进行搜索，如果搜索到了的话就进行下一次递归，否则尝试另外一个方向。注意搜索终止的条件，不能越界，该点必须没有被搜索过，字符不相等。

Simplify Path
使用stack进行操作，可以先用split()将字符串划分成字符串数组，然后遇到..就pop，遇到.跳过，其他字符一律进栈。当字符串数组检查完之后，如果栈是空，要扩展一个"/",否则弹栈前面+'/'

Longest Valid Parentheses
维护一个栈，遇到左括号进栈，遇到右括号判断栈是否为空。如果为空，说明当前位置不会是一个合法的括号匹配的开始，应当将start+1.否则弹栈，然后判断最大值。在判断最大值是，如果栈为空，那么长度是当前位置-start+1,如果栈不空，说明栈内还有暂时没匹配完的元素，而刚刚匹配的已经弹出，所以应当是位置-stack.peek();


Interleaving String
判断s3是不是能按照s1,s2的顺序每次取一个字符出来组合在一起形成，二维DP.
考虑递推式：取s1的前i字符和s2的前j字符，看是否和s3的前i+j位字符相等。相等的条件首先是要保证s3的第i+j-1位字符和s2的第j-1位字符或者s1的第i-1位字符相等，并且还要保证s1或者s1的前i-1位和s2的前j-1位相等，也就是之前已经满足条件的情况下，当前字符满足才能说加上当前字符后也满足。因此递推式是dp[i][j] = (dp[i-1][j]&&s1.charAt([i-1])==s3.charAt(i+j-1) )||(dp[i][j-1]&&s2.charAt(j-1)==s3.charAt(i+j-1)); 

Candy
和Trapping Water很像，算是一个左右扫描的动态规划问题，先从左往右扫一遍，遇到rating更大的就多放一个candy，否则放1个。然后从后往前再扫一遍，如果遇到大rating的，先比后一个多放一个，然后判断一下现在的结果和之前那次扫描的结果哪个需要更多，选择更多的作为最终的结果，把结果累加起来即可。

Two Sum
两种方法，一种双指针前后往中间搜索，另外一种用hashmap,搜索到一个值如果hashmap没有就把target-curnumber加入hashmap，下次只要搜索到即可。

Word Ladder
BFS，维护一个表来记录每个单词对应的distance。对当前检查的词的每一位都用a-z替换一次，如果在字典里就加入到queue中，并且更新一下distance。还要从dict中删除这个单词，类似于visited过了。

Palindrome Partitioning II
二维DP。在什么情况下一个字符串才是palinrome的，用前后两个指针指向两个字符，1. 如果这两个字符都指向相同的值，并且后-前<2（意思是，两个指针指向两个相邻的字符或者指向同一个字符。） 2. 两个字符串前+1后-1是palindrome,并且char i = char j，那么[i,j]就是palindrome。类似于longest palindrome substring的思想，找到对称轴然后向两边扩展。由于最坏情况是每个单独字符才能组成palindrome，因此最开始每个位置的结果都是len-i
,在更新时要判断要选取原值和cut[j+1]+1的最小值。字符串要从最后一个位置向前扫描，最后的最小值是cut[0]-1

Minimum Window Substring
因为可以跳过没在字典里面的字符（也就是这个串不需要包含且仅仅包含字典里面的字符，有一些不在字典的仍然可以满足要求），所以遇到没在字典里面的字符可以继续移动窗口右端，而移动窗口左端的条件是当找到满足条件的串之后，一直移动窗口左端直到有字典里的字符不再在窗口里。在实现中就是维护一个HashMap，一开始key包含字典中所有字符，value就是该字符的数量，然后遇到字典中字符时就将对应字符的数量减一。

Substring with concatenation of all words
为那些单词是定长的，所以本质上和单一个字符一样。和Longest Substring Without Repeating Characters的区别只在于我们需要维护一个字典，然后保证目前的串包含字典里面的单词有且仅有一次。思路仍然是维护一个窗口，如果当前单词在字典中，则继续移动窗口右端，否则窗口左端可以跳到字符串下一个单词了。假设源字符串的长度为n，字典中单词的长度为l。因为不是一个字符，所以我们需要对源字符串所有长度为l的子串进行判断。做法是i从0到l-1个字符开始，得到开始index分别为i, i+l, i+2*l, ...的长度为l的单词。这样就可以保证判断到所有的满足条件的串。

Median of Two Sorted Arrays
解决此题的方法可以依照：寻找一个unioned sorted array中的第k大（从1开始数）的数。因而等价于寻找并判断两个sorted array中第k/2（从1开始数）大的数。
特殊化到求median，那么对于奇数来说，就是求第(m+n)/2+1（从1开始数）大的数。
而对于偶数来说，就是求第(m+n)/2大（从1开始数）和第(m+n)/2+1大（从1开始数）的数的算术平均值。
那么如何判断两个有序数组A,B中第k大的数呢？
我们需要判断A[k/2-1]和B[k/2-1]的大小。
如果A[k/2-1]==B[k/2-1]，那么这个数就是两个数组中第k大的数。
如果A[k/2-1]<B[k/2-1], 那么说明A[0]到A[k/2-1]都不可能是第k大的数，所以需要舍弃这一半，继续从A[k/2]到A[A.length-1]继续找。当然，因为这里舍弃了A[0]到A[k/2-1]这k/2个数，那么第k大也就变成了，第k-k/2个大的数了。
如果 A[k/2-1]>B[k/2-1]，就做之前对称的操作就好。
这样整个问题就迎刃而解了。
当然，边界条件页不能少，需要判断是否有一个数组长度为0，以及k==1时候的情况。
因为除法是向下取整，并且页为了方便起见，对每个数组的分半操作采取：
int partA = Math.min(k/2,m);
int partB = k - partA;
 为了能保证上面的分半操作正确，需要保证A数组的长度小于B数组的长度。

Divide Two Integer
一个一个减的话超时，因此需要指数级增加。先从最高位开始，b+b,2b+2b,4b+4b，直到找到和超过a时，我们知道加多了，因此和的部分要砍去一半，但是商不用动。得到剩余的数字继续按这种方法直到被除数小于除数为止。在计算一开始要判断被除数和除数的正负号。

Word Break II
思路接近于NP问题。每次先分解出一个结果集，然后继续遍历剩余的子串，如果有子串出现在字典中就加入结果集，并且进入下一层递归。LEETCODE有一个非常tricky的测试集，因此需要先运行word break I的代码，将不能break的结果过滤掉，否则会LTE。

Decode Ways
DP思想，新加入的数有几种可能的解码方式？1. 新加入的字符dp[i]作为单独的一个字符，不能与之前的字符组合起来，因此加入这个字符串的解码方式和加入之前一位没有区别，因此是dp[i-1]。2. 新加入的字符和之前的字符能组合起来形成新的字符，那么此时必定dp[i]只能和dp[i-1]组合起来形成1个新的字符串，那么解析的方式就是dp[i-2]种。因此总结起来dp[i] = dp[i-1]+dp[i-2]种。但是这里有一定的限制，首先不管是i-1还是i-2，开头的数字都不能为0，如果i-1不为0，我们可以先让dp[i] = dp[i-1]，如果dp[i-2]也不是0，说明i-1和i可以组合起来，那么组合起来之后的数字一定要大于0小于26，只有这样我们才能让dp[i]+=dp[i-2]。最后返回dp[s.length]就好了。

atoi
各种case都考虑进去，包括正负号，越界什么的。

Text justification
在判断字符串长度是否越界的时候，要把空格数也累加进去，每个单词后面暂时放置一个空格。发现超出之后计算可填充单词所占长度然后计算要在每个空格中多加几个空格。然后先ppend单词，再append应当加入的空格再append要多加入几个空格。如果一行内能填充的单词都已填充完毕但是尾部还有位置，再填入空格。对于最后一行，先填入字符，然后加空格。最后再将剩余位置用空格填充。

Surrounded Regions
单独处理四个边，如果边上有O，那么BFS看四周的节点，遇见O就变成#。然后将所有依然为0的节点变成X，最后将所有#变成O。需要注意的是BFS时，可以将坐标i,j打包成一个数，然后存在Queue里，然后poll出来之后再还原。
        int code = i*board[0].length+j; 
        int row = code/board[0].length;  
        int col = code%board[0].length;  


LRU cache
按照题目要求，要实现get和set功能，为了满足随机存储的需求我们首先想到的一般是用数组，如果用链表会有O(n)的访问时间。然而他又有另一个条件就是要维护least used的队列，也就是说经常用的放在前面，用的少的放在后面。这样当资源超过cache的容积的时候就可以把用得最少的资源删掉。这就要求我们要对节点有好的删除和插入操作，这个要求又会让我们想到用链表，因为数组的删除和插入是O(n)复杂度的。
那么我们能不能维护一个数据结构使得访问操作和插入删除操作都是O(1)复杂度的呢？答案是肯定的。这个数据结构比较复杂，是用一个hash表加上一个双向链表来实现。基本思路是这样的，用一个hash表来维护结点的位置关系，也就是hash表的key就是资源本身的key，value是资源的结点（包含key和value的信息）。然后把结点维护成一个双向链表构成的队列，这样子如果我们要访问某一个结点，那么可以通过hash表和key来找到结点，从而取到相应的value。而当我们想要删除或者插入结点时，我们还是通过hash表找到结点，然后通过双向链表和队列的尾结点把自己删除同时插入到队尾。通过hash表访问结点我们可以认为是O(1)的操作（假设hash函数足够好），然后双向链表的插入删除操作也是O(1)的操作。如此我们便实现了用O(1)时间来完成所有LRU cache的操作。空间上就是对于每一个资源有一个hash表的的项以及一个对应的结点（包含前后指针和资源的<key, value>）

wildcard matching
跟Regular Expression Matching一样，还是维护一个假设我们维护一个布尔数组res[i],代表s的前i个字符和p的前j个字符是否匹配(这里因为每次i的结果只依赖于j-1的结果，所以不需要二维数组，只需要一个一维数组来保存上一行结果即可），递推公式分两种情况：
    (1)p[j]不是'*'。情况比较简单，只要判断如果当前s的i和p的j上的字符一样（如果有p在j上的字符是'?'，也是相同），并且res[i]==true，则更新res[i+1]为true，否则res[i+1]=false;  
    (2)p[j]是'*'。因为'*'可以匹配任意字符串，所以在前面的res[i]只要有true，那么剩下的          res[i+1], res[i+2],...,res[s.length()]就都是true了。

Word Ladder II
思路上和Word Ladder是比较类似的，但是因为是要求出所有路径，仅仅保存路径长度是不够的，而且这里还有更多的问题，那就是为了得到所有路径，不是每个结点访问一次就可以标记为visited了，因为有些访问过的结点也会是别的路径上的结点，所以访问的集合要进行回溯（也就是标记回未访问）。所以时间上不再是一次广度优先搜索的复杂度了，取决于结果路径的数量。同样空间上也是相当高的复杂度，因为我们要保存过程中满足的中间路径到某个数据结构中，以便最后可以获取路径，这里我们维护一个HashMap，把一个结点前驱结点都进行保存。
在LeetCode中用Java实现上述算法非常容易超时。为了提高算法效率，需要注意一下两点：
1）在替换String的某一位的字符时，先转换成char数组再操作；
2）如果按照正常的方法从start找end，然后根据这个来构造路径，代价会比较高，因为保存前驱结点容易，而保存后驱结点则比较困难。所以我们在广度优先搜索时反过来先从end找start，最后再根据生成的前驱结点映射从start往end构造路径，这样算法效率会有明显提高。

valid number
正则表达式更简单，否则很麻烦


Max Points on a line
首先每两条直线计算一下斜率，每个内层循环用hashmap保存斜率，map的value是这个斜率的数目，如果遇到相同的斜率直接加1，因为内层循环是对于当前同一个点计算的，那么同斜率又同时经过一个点一定在一条直线上。当考虑完当前点后获得出现斜率最多的次数，并且加上其他与当前点坐标完全相同的点的数量，再求一个global的max